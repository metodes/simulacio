```ruby
import numpy as np

k_b = 1.380649e-23

def  probabilitat(energia, temperatura):
    # Calcula la probabilitat per a una energia i temperatura donades
    beta = 1/(k_b * temperatura)
    return np.exp(-energia * beta)

def montecarlo(num_estats, temperatura, num_iteracions):
    # Simula la col.lectivitat canònica utilitzant tècniques de Monte Carlo
    A = 1.0

    # Inicialitzem els arrays d'estats i energies
    estats = np.arange(1, num_estats + 1)
    energies = estats * A * k_b

    # Inicialitzem els comptadors per seguir quants cops passa per cada estat
    comptadors_estat = np.zeros(num_estats)

    # Realitzem la simulació de Monte Carlo
    for _ in range(num_iteracions):
        # Seleccionem un estat aleatori
        index_estat = np.random.randint(num_estats)

        # Calculem la probabilitat de Boltzmann per a l'estat seleccionat
        prob = probabilitat(energies[index_estat], temperatura)

        # Determinem si acceptem la transició d'estat basant-nos en la probabilitat de Boltzmann
        if np.random.rand() < prob:
            comptadors_estat[index_estat] += 1

    # Normalitzem els comptadors d'estats per obtenir probabilitats
    probs_estat = comptadors_estat / num_iteracions

    return estats, probs_estat

# Paràmetres
temperatura = 1.0
num_estats = 10 
num_iteracions = 1000000

# Executem la simulació
estats, probabilitats = montecarlo(num_estats, temperatura, num_iteracions)

print("Estats\tProbabilitat")
for estat, prob in zip(estats, probabilitats):
    print(f"{estat}\t{prob}")
```
